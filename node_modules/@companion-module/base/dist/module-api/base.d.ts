import { CompanionActionDefinitions, CompanionActionInfo } from './action.js';
import { CompanionFeedbackDefinitions } from './feedback.js';
import { CompanionPresetDefinitions } from './preset.js';
import { InstanceStatus, LogLevel } from './enums.js';
import { InstanceBaseShared } from '../instance-base.js';
import { CompanionVariableDefinition, CompanionVariableValue, CompanionVariableValues } from './variable.js';
import { OSCSomeArguments } from '../common/osc.js';
import { SomeCompanionConfigField } from './config.js';
import { CompanionHTTPRequest, CompanionHTTPResponse } from './http.js';
export declare abstract class InstanceBase<TConfig> implements InstanceBaseShared<TConfig> {
    #private;
    readonly id: string;
    /**
     * Create an instance of the module
     */
    constructor(internal: unknown);
    private _handleInit;
    private _handleDestroy;
    private _handleConfigUpdate;
    private _handleExecuteAction;
    private _handleUpdateFeedbacks;
    private _handleUpdateActions;
    private _handleGetConfigFields;
    private _handleHttpRequest;
    private _handleLearnAction;
    private _handleLearnFeedback;
    private _handleStartStopRecordActions;
    /**
     * Main initialization function called
     * once the module is OK to start doing things.
     */
    abstract init(config: TConfig): Promise<void>;
    /**
     * Clean up the instance before it is destroyed.
     */
    abstract destroy(): Promise<void>;
    /**
     * Called when the configuration is updated.
     * @param config The new config object
     */
    abstract configUpdated(config: TConfig): Promise<void>;
    /**
     * Save an updated configuration object
     * @param newConfig The new config object
     */
    saveConfig(newConfig: TConfig): void;
    /**
     * Creates the configuration fields for web config
     */
    abstract getConfigFields(): SomeCompanionConfigField[];
    /**
     * Handle HTTP requests from Companion
     * @param request partial request object from Express
     */
    handleHttpRequest?(request: CompanionHTTPRequest): CompanionHTTPResponse | Promise<CompanionHTTPResponse>;
    /**
     * Handle request from Companion to start/stop recording actions
     * @param isRecording whether recording is now running
     */
    handleStartStopRecordActions?(isRecording: boolean): void;
    /**
     * Set the action definitions for this instance
     * @param actions The action definitions
     */
    setActionDefinitions(actions: CompanionActionDefinitions): void;
    /**
     * Set the feedback definitions for this instance
     * @param feedbacks The feedback definitions
     */
    setFeedbackDefinitions(feedbacks: CompanionFeedbackDefinitions): void;
    /**
     * Set the peset definitions for this instance
     * @param presets The preset definitions
     */
    setPresetDefinitions(presets: CompanionPresetDefinitions): void;
    /**
     * Set the variable definitions for this instance
     * @param variables The variable definitions
     */
    setVariableDefinitions(variables: CompanionVariableDefinition[]): void;
    /**
     * Set the values of some variables
     * @param values The new values for the variables
     */
    setVariableValues(values: CompanionVariableValues): void;
    /**
     * Get the last set value of a variable from this connection
     * @param variableId id of the variable
     * @returns The value
     */
    getVariableValue(variableId: string): CompanionVariableValue | undefined;
    /**
     * Parse and replace all the variables in a string
     * @param text The text to parse
     * @returns The string with variables replaced with their values
     */
    parseVariablesInString(text: string): Promise<string>;
    /**
     * Request all feedbacks of the specified types to be checked for changes
     * @param feedbackTypes The feedback types to check
     */
    checkFeedbacks(...feedbackTypes: string[]): void;
    /**
     * Request the specified feedback instances to be checked for changes
     * @param feedbackIds The ids of the feedback instances to check
     */
    checkFeedbacksById(...feedbackIds: string[]): void;
    /** @deprecated */
    _getAllActions(): {
        id: string;
        actionId: string;
        controlId: string;
        options: {
            [key: string]: import("./input.js").InputValue | undefined;
        };
    }[];
    /**
     * Call subscribe on all currently known placed actions.
     * It can be useful to trigger this upon establishing a connection, to ensure all data is loaded.
     * @param actionIds The actionIds to call subscribe for. If no values are provided, then all are called.
     */
    subscribeActions(...actionIds: string[]): void;
    /**
     * Call unsubscribe on all currently known placed actions.
     * It can be useful to do some cleanup upon a connection closing.
     * @param actionIds The actionIds to call subscribe for. If no values are provided, then all are called.
     */
    unsubscribeActions(...actionIds: string[]): void;
    /** @deprecated */
    _getAllFeedbacks(): {
        id: string;
        feedbackId: string;
        controlId: string;
        options: {
            [key: string]: import("./input.js").InputValue | undefined;
        };
    }[];
    /**
     * Call subscribe on all currently known placed feedbacks.
     * It can be useful to trigger this upon establishing a connection, to ensure all data is loaded.
     * @param feedbackIds The feedbackIds to call subscribe for. If no values are provided, then all are called.
     */
    subscribeFeedbacks(...feedbackIds: string[]): void;
    /**
     * Call unsubscribe on all currently known placed feedbacks.
     * It can be useful to do some cleanup upon a connection closing.
     * @param feedbackIds The feedbackIds to call subscribe for. If no values are provided, then all are called.
     */
    unsubscribeFeedbacks(...feedbackIds: string[]): void;
    /**
     * Add an action to the current recording session
     * @param action The action to be added to the recording session
     * @param uniquenessId A unique id for the action being recorded. This should be different for each action, but by passing the same as a previous call will replace the previous value.
     */
    recordAction(action: Omit<CompanionActionInfo, 'id' | 'controlId'>, uniquenessId?: string): void;
    /**
     * Experimental: This method may change without notice. Do not use!
     * Set the value of a custom variable
     * @param variableId
     * @param value
     * @returns Promise which resolves upon success, or rejects if the variable no longer exists
     */
    setCustomVariableValue(variableId: string, value: CompanionVariableValue): void;
    /**
     * Send an osc message from the system osc sender
     * @param host destination ip address
     * @param port destination port number
     * @param path message path
     * @param args mesage arguments
     */
    oscSend(host: string, port: number, path: string, args: OSCSomeArguments): void;
    /**
     * Update the status of this connection
     * @param status The status level
     * @param message Additional information about the status
     *
     * ### Example
     * ```js
     * this.updateStatus(InstanceStatus.Ok)
     * ```
     */
    updateStatus(status: InstanceStatus, message?: string | null): void;
    /**
     * Write a line to the log
     * @param level The level of the message
     * @param message The message text to write
     */
    log(level: LogLevel, message: string): void;
}
//# sourceMappingURL=base.d.ts.map