"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstanceBase = void 0;
const tslib_1 = require("tslib");
const util_js_1 = require("../util.js");
const p_queue_1 = tslib_1.__importDefault(require("p-queue"));
const base_js_1 = require("../internal/base.js");
const upgrade_js_1 = require("../internal/upgrade.js");
const feedback_js_1 = require("../internal/feedback.js");
const ipc_wrapper_js_1 = require("../host-api/ipc-wrapper.js");
class InstanceBase {
    #ipcWrapper;
    #upgradeScripts;
    id;
    #lifecycleQueue = new p_queue_1.default({ concurrency: 1 });
    #initialized = false;
    #recordingActions = false;
    #actionDefinitions = new Map();
    #feedbackDefinitions = new Map();
    #variableDefinitions = new Map();
    #feedbackInstances = new Map();
    #actionInstances = new Map();
    #variableValues = new Map();
    /**
     * Create an instance of the module
     */
    constructor(internal) {
        if (!(0, base_js_1.isInstanceBaseProps)(internal) || !internal._isInstanceBaseProps)
            throw new Error(`Module instance is being constructed incorrectly. Make sure you aren't trying to do this manually`);
        this.#ipcWrapper = new ipc_wrapper_js_1.IpcWrapper({
            init: this._handleInit.bind(this),
            destroy: this._handleDestroy.bind(this),
            updateConfig: this._handleConfigUpdate.bind(this),
            executeAction: this._handleExecuteAction.bind(this),
            updateFeedbacks: this._handleUpdateFeedbacks.bind(this),
            updateActions: this._handleUpdateActions.bind(this),
            getConfigFields: this._handleGetConfigFields.bind(this),
            handleHttpRequest: this._handleHttpRequest.bind(this),
            learnAction: this._handleLearnAction.bind(this),
            learnFeedback: this._handleLearnFeedback.bind(this),
            startStopRecordActions: this._handleStartStopRecordActions.bind(this),
        }, (msg) => {
            process.send(msg);
        }, 5000);
        process.on('message', (msg) => {
            this.#ipcWrapper.receivedMessage(msg);
        });
        this.#upgradeScripts = internal.upgradeScripts;
        this.id = internal.id;
        this.log('debug', 'Initializing');
    }
    async _handleInit(msg) {
        return this.#lifecycleQueue.add(async () => {
            if (this.#initialized)
                throw new Error('Already initialized');
            const actions = msg.actions;
            const feedbacks = msg.feedbacks;
            let config = msg.config;
            // Create initial config object
            if (msg.isFirstInit) {
                const newConfig = {};
                const fields = this.getConfigFields();
                for (const field of fields) {
                    if ('default' in field) {
                        newConfig[field.id] = field.default;
                    }
                }
                config = newConfig;
                this.saveConfig(config);
            }
            /**
             * Performing upgrades during init requires a fair chunk of work.
             * Some actions/feedbacks will be using the upgradeIndex of the instance, but some may have their own upgradeIndex on themselves if they are from an import.
             */
            const { updatedActions, updatedFeedbacks, updatedConfig } = (0, upgrade_js_1.runThroughUpgradeScripts)(actions, feedbacks, msg.lastUpgradeIndex, this.#upgradeScripts, config);
            config = updatedConfig ?? config;
            // Send the upgraded data back to companion now. Just so that if the init crashes, this doesnt have to be repeated
            const pSendUpgrade = this.#ipcWrapper.sendWithCb('upgradedItems', {
                updatedActions,
                updatedFeedbacks,
            });
            // Now we can initialise the module
            try {
                await this.init(config);
                this.#initialized = true;
            }
            catch (e) {
                console.trace(`Init failed: ${e}`);
                throw e;
            }
            finally {
                // Only now do we need to await the upgrade
                await pSendUpgrade;
            }
            setImmediate(() => {
                // Subscribe all of the actions and feedbacks
                this._handleUpdateActions({ actions }, true);
                this._handleUpdateFeedbacks({ feedbacks }, true);
            });
            return {
                hasHttpHandler: typeof this.handleHttpRequest === 'function',
                hasRecordActionsHandler: typeof this.handleStartStopRecordActions == 'function',
                newUpgradeIndex: this.#upgradeScripts.length - 1,
                updatedConfig: config,
            };
        });
    }
    async _handleDestroy() {
        await this.#lifecycleQueue.add(async () => {
            if (!this.#initialized)
                throw new Error('Not initialized');
            await this.destroy();
            this.#initialized = false;
        });
    }
    async _handleConfigUpdate(config) {
        await this.#lifecycleQueue.add(async () => {
            if (!this.#initialized)
                throw new Error('Not initialized');
            await this.configUpdated(config);
        });
    }
    async _handleExecuteAction(msg) {
        const actionDefinition = this.#actionDefinitions.get(msg.action.actionId);
        if (!actionDefinition)
            throw new Error(`Unknown action: ${msg.action.actionId}`);
        await actionDefinition.callback({
            id: msg.action.id,
            actionId: msg.action.actionId,
            controlId: msg.action.controlId,
            options: msg.action.options,
            _deviceId: msg.deviceId,
            _page: msg.action.page,
            _bank: msg.action.bank,
        });
    }
    async _handleUpdateFeedbacks(msg, skipUpgrades) {
        const newValues = [];
        // Run through upgrade scripts if needed
        if (!skipUpgrades) {
            (0, upgrade_js_1.runThroughUpgradeScripts)({}, msg.feedbacks, null, this.#upgradeScripts, undefined);
        }
        for (const [id, feedback] of Object.entries(msg.feedbacks)) {
            const existing = this.#feedbackInstances.get(id);
            const feedbackId = existing?.feedbackId ?? feedback?.feedbackId;
            const definition = feedbackId ? this.#feedbackDefinitions.get(feedbackId) : null;
            if (existing) {
                // Call unsubscribe
                if (definition?.unsubscribe) {
                    try {
                        definition.unsubscribe((0, feedback_js_1.convertFeedbackInstanceToEvent)(definition.type, existing));
                    }
                    catch (e) {
                        console.error(`Feedback unsubscribe failed: ${JSON.stringify(existing)} - ${e?.message ?? e} ${e?.stack}`);
                    }
                }
            }
            if (!feedback) {
                // Deleted
                this.#feedbackInstances.delete(id);
            }
            else {
                // TODO module-lib - deep freeze the feedback to avoid mutation?
                this.#feedbackInstances.set(id, feedback);
                // Inserted or updated
                if (definition?.subscribe) {
                    try {
                        definition.subscribe((0, feedback_js_1.convertFeedbackInstanceToEvent)(definition.type, feedback));
                    }
                    catch (e) {
                        console.error(`Feedback subscribe failed: ${JSON.stringify(feedback)} - ${e?.message ?? e} ${e?.stack}`);
                    }
                }
                // Calculate the new value for the feedback
                if (definition) {
                    let value;
                    try {
                        value = (0, feedback_js_1.callFeedbackOnDefinition)(definition, feedback);
                    }
                    catch (e) {
                        console.error(`Feedback check failed: ${JSON.stringify(feedback)} - ${e?.message ?? e} ${e?.stack}`);
                    }
                    newValues.push({
                        id: id,
                        controlId: feedback.controlId,
                        value: value,
                    });
                }
            }
        }
        // Send the new values back
        if (Object.keys(newValues).length > 0) {
            this.#ipcWrapper.sendWithNoCb('updateFeedbackValues', {
                values: newValues,
            });
        }
    }
    async _handleUpdateActions(msg, skipUpgrades) {
        // Run through upgrade scripts if needed
        if (!skipUpgrades) {
            // const pendingUpgrades = Object.values(msg.actions).filter((act) => typeof act?.upgradeIndex === 'number')
            // if (pendingUpgrades.length > 0) {
            // 	//
            // }
            (0, upgrade_js_1.runThroughUpgradeScripts)(msg.actions, {}, null, this.#upgradeScripts, undefined);
        }
        for (const [id, action] of Object.entries(msg.actions)) {
            const existing = this.#actionInstances.get(id);
            const definition = existing && this.#actionDefinitions.get(existing.actionId);
            if (existing) {
                // Call unsubscribe
                if (definition?.unsubscribe) {
                    try {
                        definition.unsubscribe(existing);
                    }
                    catch (e) {
                        console.error(`Action unsubscribe failed: ${JSON.stringify(existing)} - ${e?.message ?? e} ${e?.stack}`);
                    }
                }
            }
            if (!action) {
                // Deleted
                this.#actionInstances.delete(id);
            }
            else {
                // TODO module-lib - deep freeze the action to avoid mutation?
                this.#actionInstances.set(id, action);
                // Inserted or updated
                if (definition?.subscribe) {
                    try {
                        definition.subscribe(action);
                    }
                    catch (e) {
                        console.error(`Action subscribe failed: ${JSON.stringify(action)} - ${e?.message ?? e} ${e?.stack}`);
                    }
                }
            }
        }
    }
    async _handleGetConfigFields(_msg) {
        return {
            fields: (0, base_js_1.serializeIsVisibleFn)(this.getConfigFields()),
        };
    }
    async _handleHttpRequest(msg) {
        if (!this.handleHttpRequest)
            throw new Error(`handleHttpRequest is not supported!`);
        const res = await this.handleHttpRequest(msg.request);
        return { response: res };
    }
    async _handleLearnAction(msg) {
        const definition = this.#actionDefinitions.get(msg.action.actionId);
        if (definition && definition.learn) {
            const newOptions = await definition.learn({
                id: msg.action.id,
                actionId: msg.action.actionId,
                controlId: msg.action.controlId,
                options: msg.action.options,
                _deviceId: undefined,
                _page: msg.action.page,
                _bank: msg.action.bank,
            });
            return {
                options: newOptions,
            };
        }
        else {
            // Not supported
            return {
                options: undefined,
            };
        }
    }
    async _handleLearnFeedback(msg) {
        const definition = this.#feedbackDefinitions.get(msg.feedback.feedbackId);
        if (definition && definition.learn) {
            const newOptions = await definition.learn({
                id: msg.feedback.id,
                feedbackId: msg.feedback.feedbackId,
                controlId: msg.feedback.controlId,
                options: msg.feedback.options,
                type: definition.type,
            });
            return {
                options: newOptions,
            };
        }
        else {
            // Not supported
            return {
                options: undefined,
            };
        }
    }
    async _handleStartStopRecordActions(msg) {
        if (!msg.recording) {
            if (!this.#recordingActions) {
                // Already stopped
                return;
            }
        }
        else {
            if (this.#recordingActions) {
                // Already running
                return;
            }
        }
        if (!this.handleStartStopRecordActions) {
            this.#recordingActions = false;
            throw new Error('Recording actions is not supported by this module!');
        }
        this.#recordingActions = msg.recording;
        this.handleStartStopRecordActions(this.#recordingActions);
    }
    /**
     * Save an updated configuration object
     * @param newConfig The new config object
     */
    saveConfig(newConfig) {
        this.#ipcWrapper.sendWithNoCb('saveConfig', { config: newConfig });
    }
    /**
     * Set the action definitions for this instance
     * @param actions The action definitions
     */
    setActionDefinitions(actions) {
        const hostActions = [];
        this.#actionDefinitions.clear();
        for (const [actionId, action] of Object.entries(actions)) {
            if (action) {
                hostActions.push({
                    id: actionId,
                    name: action.name,
                    description: action.description,
                    options: (0, base_js_1.serializeIsVisibleFn)(action.options),
                    hasLearn: !!action.learn,
                });
                // Remember the definition locally
                this.#actionDefinitions.set(actionId, action);
            }
        }
        this.#ipcWrapper.sendWithNoCb('setActionDefinitions', { actions: hostActions });
    }
    /**
     * Set the feedback definitions for this instance
     * @param feedbacks The feedback definitions
     */
    setFeedbackDefinitions(feedbacks) {
        const hostFeedbacks = [];
        this.#feedbackDefinitions.clear();
        for (const [feedbackId, feedback] of Object.entries(feedbacks)) {
            if (feedback) {
                hostFeedbacks.push({
                    id: feedbackId,
                    name: feedback.name,
                    description: feedback.description,
                    options: (0, base_js_1.serializeIsVisibleFn)(feedback.options),
                    type: feedback.type,
                    defaultStyle: 'defaultStyle' in feedback ? feedback.defaultStyle : undefined,
                    hasLearn: !!feedback.learn,
                });
                // Remember the definition locally
                this.#feedbackDefinitions.set(feedbackId, feedback);
            }
        }
        this.#ipcWrapper.sendWithNoCb('setFeedbackDefinitions', { feedbacks: hostFeedbacks });
    }
    /**
     * Set the peset definitions for this instance
     * @param presets The preset definitions
     */
    setPresetDefinitions(presets) {
        const hostPresets = [];
        for (const [id, preset] of Object.entries(presets)) {
            if (preset) {
                hostPresets.push({
                    ...preset,
                    id,
                });
            }
        }
        this.#ipcWrapper.sendWithNoCb('setPresetDefinitions', { presets: hostPresets });
    }
    /**
     * Set the variable definitions for this instance
     * @param variables The variable definitions
     */
    setVariableDefinitions(variables) {
        const hostVariables = [];
        this.#variableDefinitions.clear();
        for (const variable of variables) {
            hostVariables.push({
                id: variable.variableId,
                name: variable.name,
            });
            // Remember the definition locally
            this.#variableDefinitions.set(variable.variableId, variable);
            if (!this.#variableValues.has(variable.variableId)) {
                // Give us a local cached value of something
                this.#variableValues.set(variable.variableId, '');
            }
        }
        const validIds = new Set(this.#variableDefinitions.keys());
        for (const id of this.#variableValues.keys()) {
            if (!validIds.has(id)) {
                // Delete any local cached value
                this.#variableValues.delete(id);
            }
        }
        this.#ipcWrapper.sendWithNoCb('setVariableDefinitions', { variables: hostVariables });
    }
    /**
     * Set the values of some variables
     * @param values The new values for the variables
     */
    setVariableValues(values) {
        const hostValues = [];
        for (const [variableId, value] of Object.entries(values)) {
            if (this.#variableDefinitions.has(variableId)) {
                // update the cached value
                this.#variableValues.set(variableId, value ?? '');
                hostValues.push({
                    id: variableId,
                    value: value ?? '',
                });
            }
            else {
                // tell companion to delete the value
                hostValues.push({
                    id: variableId,
                    value: undefined,
                });
            }
        }
        this.#ipcWrapper.sendWithNoCb('setVariableValues', { newValues: hostValues });
    }
    /**
     * Get the last set value of a variable from this connection
     * @param variableId id of the variable
     * @returns The value
     */
    getVariableValue(variableId) {
        return this.#variableValues.get(variableId);
    }
    /**
     * Parse and replace all the variables in a string
     * @param text The text to parse
     * @returns The string with variables replaced with their values
     */
    async parseVariablesInString(text) {
        const res = await this.#ipcWrapper.sendWithCb('parseVariablesInString', { text: text });
        return res.text;
    }
    /**
     * Request all feedbacks of the specified types to be checked for changes
     * @param feedbackTypes The feedback types to check
     */
    checkFeedbacks(...feedbackTypes) {
        const newValues = [];
        const types = new Set(feedbackTypes);
        for (const [id, feedback] of this.#feedbackInstances.entries()) {
            const definition = this.#feedbackDefinitions.get(feedback.feedbackId);
            if (definition) {
                if (types.size > 0 && !types.has(feedback.feedbackId)) {
                    // Not to be considered
                    continue;
                }
                try {
                    // Calculate the new value for the feedback
                    newValues.push({
                        id: id,
                        controlId: feedback.controlId,
                        value: (0, feedback_js_1.callFeedbackOnDefinition)(definition, feedback),
                    });
                }
                catch (e) {
                    console.error(`Feedback check failed: ${JSON.stringify(feedback)} - ${e?.message ?? e} ${e?.stack}`);
                }
            }
        }
        // Send the new values back
        if (Object.keys(newValues).length > 0) {
            this.#ipcWrapper.sendWithNoCb('updateFeedbackValues', {
                values: newValues,
            });
        }
    }
    /**
     * Request the specified feedback instances to be checked for changes
     * @param feedbackIds The ids of the feedback instances to check
     */
    checkFeedbacksById(...feedbackIds) {
        const newValues = [];
        for (const id of feedbackIds) {
            const feedback = this.#feedbackInstances.get(id);
            const definition = feedback && this.#feedbackDefinitions.get(feedback.feedbackId);
            if (feedback && definition) {
                try {
                    // Calculate the new value for the feedback
                    newValues.push({
                        id: id,
                        controlId: feedback.controlId,
                        value: (0, feedback_js_1.callFeedbackOnDefinition)(definition, feedback),
                    });
                }
                catch (e) {
                    console.error(`Feedback check failed: ${JSON.stringify(feedback)} - ${e?.message ?? e} ${e?.stack}`);
                }
            }
        }
        // Send the new values back
        if (Object.keys(newValues).length > 0) {
            this.#ipcWrapper.sendWithNoCb('updateFeedbackValues', {
                values: newValues,
            });
        }
    }
    /** @deprecated */
    _getAllActions() {
        return Array.from(this.#actionInstances.values()).map((act) => ({
            id: act.id,
            actionId: act.actionId,
            controlId: act.controlId,
            options: act.options,
        }));
    }
    /**
     * Call subscribe on all currently known placed actions.
     * It can be useful to trigger this upon establishing a connection, to ensure all data is loaded.
     * @param actionIds The actionIds to call subscribe for. If no values are provided, then all are called.
     */
    subscribeActions(...actionIds) {
        let actions = Array.from(this.#actionInstances.values());
        const actionIdSet = new Set(actionIds);
        if (actionIdSet.size)
            actions = actions.filter((fb) => actionIdSet.has(fb.actionId));
        for (const act of actions) {
            const def = this.#actionDefinitions.get(act.actionId);
            if (def && def.subscribe) {
                def.subscribe({
                    id: act.id,
                    actionId: act.actionId,
                    controlId: act.controlId,
                    options: act.options,
                });
            }
        }
    }
    /**
     * Call unsubscribe on all currently known placed actions.
     * It can be useful to do some cleanup upon a connection closing.
     * @param actionIds The actionIds to call subscribe for. If no values are provided, then all are called.
     */
    unsubscribeActions(...actionIds) {
        let actions = Array.from(this.#actionInstances.values());
        const actionIdSet = new Set(actionIds);
        if (actionIdSet.size)
            actions = actions.filter((fb) => actionIdSet.has(fb.actionId));
        for (const act of actions) {
            const def = this.#actionDefinitions.get(act.actionId);
            if (def && def.unsubscribe) {
                def.unsubscribe({
                    id: act.id,
                    actionId: act.actionId,
                    controlId: act.controlId,
                    options: act.options,
                });
            }
        }
    }
    /** @deprecated */
    _getAllFeedbacks() {
        return Array.from(this.#feedbackInstances.values()).map((fb) => ({
            id: fb.id,
            feedbackId: fb.feedbackId,
            controlId: fb.controlId,
            options: fb.options,
        }));
    }
    /**
     * Call subscribe on all currently known placed feedbacks.
     * It can be useful to trigger this upon establishing a connection, to ensure all data is loaded.
     * @param feedbackIds The feedbackIds to call subscribe for. If no values are provided, then all are called.
     */
    subscribeFeedbacks(...feedbackIds) {
        let feedbacks = Array.from(this.#feedbackInstances.values());
        const feedbackIdSet = new Set(feedbackIds);
        if (feedbackIdSet.size)
            feedbacks = feedbacks.filter((fb) => feedbackIdSet.has(fb.feedbackId));
        for (const fb of feedbacks) {
            const def = this.#feedbackDefinitions.get(fb.feedbackId);
            if (def && def.subscribe) {
                def.subscribe({
                    type: def.type,
                    id: fb.id,
                    feedbackId: fb.feedbackId,
                    controlId: fb.controlId,
                    options: fb.options,
                });
            }
        }
    }
    /**
     * Call unsubscribe on all currently known placed feedbacks.
     * It can be useful to do some cleanup upon a connection closing.
     * @param feedbackIds The feedbackIds to call subscribe for. If no values are provided, then all are called.
     */
    unsubscribeFeedbacks(...feedbackIds) {
        let feedbacks = Array.from(this.#feedbackInstances.values());
        const feedbackIdSet = new Set(feedbackIds);
        if (feedbackIdSet.size)
            feedbacks = feedbacks.filter((fb) => feedbackIdSet.has(fb.feedbackId));
        for (const fb of feedbacks) {
            const def = this.#feedbackDefinitions.get(fb.feedbackId);
            if (def && def.unsubscribe) {
                def.unsubscribe({
                    type: def.type,
                    id: fb.id,
                    feedbackId: fb.feedbackId,
                    controlId: fb.controlId,
                    options: fb.options,
                });
            }
        }
    }
    /**
     * Add an action to the current recording session
     * @param action The action to be added to the recording session
     * @param uniquenessId A unique id for the action being recorded. This should be different for each action, but by passing the same as a previous call will replace the previous value.
     */
    recordAction(action, uniquenessId) {
        if (!this.#recordingActions)
            throw new Error('Not currently recording actions');
        this.#ipcWrapper.sendWithNoCb('recordAction', {
            uniquenessId: uniquenessId ?? null,
            actionId: action.actionId,
            options: action.options,
        });
    }
    /**
     * Experimental: This method may change without notice. Do not use!
     * Set the value of a custom variable
     * @param variableId
     * @param value
     * @returns Promise which resolves upon success, or rejects if the variable no longer exists
     */
    setCustomVariableValue(variableId, value) {
        this.#ipcWrapper.sendWithNoCb('setCustomVariable', {
            customVariableId: variableId,
            value,
        });
    }
    /**
     * Send an osc message from the system osc sender
     * @param host destination ip address
     * @param port destination port number
     * @param path message path
     * @param args mesage arguments
     */
    oscSend(host, port, path, args) {
        this.#ipcWrapper.sendWithNoCb('send-osc', (0, util_js_1.literal)({
            host,
            port,
            path,
            args,
        }));
    }
    /**
     * Update the status of this connection
     * @param status The status level
     * @param message Additional information about the status
     *
     * ### Example
     * ```js
     * this.updateStatus(InstanceStatus.Ok)
     * ```
     */
    updateStatus(status, message) {
        this.#ipcWrapper.sendWithNoCb('set-status', (0, util_js_1.literal)({
            status,
            message: message ?? null,
        }));
    }
    /**
     * Write a line to the log
     * @param level The level of the message
     * @param message The message text to write
     */
    log(level, message) {
        this.#ipcWrapper.sendWithNoCb('log-message', (0, util_js_1.literal)({
            level,
            message,
        }));
    }
}
exports.InstanceBase = InstanceBase;
//# sourceMappingURL=base.js.map